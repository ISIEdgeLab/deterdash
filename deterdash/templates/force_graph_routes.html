{% extends "dashboard.html" %}
{% block metric_title %}
<h1 class="page-header"><i class="fa fa-bar-chart-o fa-fw"></i>{{ agent.display }}</h1>
{% endblock %}

{% block content %}
<div class="col-lg-12">
    <div class="panel panel-default">
        <div class="panel-heading">
            <span id="deter_topology_chart_title">
                <b> {{ agent.display }} </b>
            </span>
            <div class="pull-right">
                <div class="btn-group">
                    <button type="button" id="disp_route_button" class="btn btn-default btn-xs disabled">
                        Display Route
                    </button>
                    <button type="button" id="clear_route_button" class="btn btn-default btn-xs dropdown-toggle disbaled" data-toggle="dropdown">
                        Clear Routes
                        <span class="caret"></span>
                    </button>
                    <ul class="dropdown-menu pull-right clear_routes_dropdown" role="menu">
                    </ul>
                </div>
            </div>
        </div>
        <div class="panel-body" id="deter_topology" style="max-height: 600px; min-height: 600px">
            <div id="message_area"></div>
        </div>
        <script>
            var win_w = $("#deter_topology").width(),
                win_h = $("#deter_topology").height();
            var margin = {top: 5, right: 5, bottom: 5, left: 5};

            var node_rad = 10,
                node_gap = 5;

            var clear_all_routes_menu_entry = {id: "clear_all_routes", text: "All Routes", color: null, src: null, dst: null, slot: -1};
            var selected_path_nodes = [],
                path_slot = -1,
                choosing_path = false,
                route_color = d3.scaleOrdinal(d3.schemeCategory10),
                route_dropdown_menu = [clear_all_routes_menu_entry]

            var newest_zoom = null;

            var node = null,
                link = null,
                nodes = [],
                links = [],
                node_label = null;

            var simulation = d3.forceSimulation()
                .force("link", d3.forceLink()
                    .distance(60)
                    .strength(0.7)
                    .id(function(d) { return d.id; }))
                .force("collision", d3.forceCollide()
                     .radius(function(d) { return node_rad+node_gap }).iterations(16))
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(win_w/2, win_h/2))
                .on("tick", ticked)

            var svg = d3
                .select("#deter_topology")
                .append("svg")
                .attr("cursor", "move")
                .call(d3.zoom().scaleExtent([0.5, 10]).on("zoom", zoomed));

            // build the arrow.
            svg.append("svg:defs").selectAll("marker")
                    .data(["end"])      // Different link/path types can be defined here
                .enter().append("svg:marker")    // This section adds in the arrows
                    .attr("id", String)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 15)
                    .attr("refY", -1.5)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                .append("path")
                    .attr("d", "M0,-5L10,0L0,5");

            d3.select(window).on("resize", resize);

            var link_selection = svg.append("g").attr("class", "links");
            var node_selection = svg.append("g").attr("class", "nodes");
            var route_dropdown_menu_selection = d3.select(".clear_routes_dropdown");

            resize();   // set initial size.

            function resize() {
                var win_w = $("#deter_topology").width(),
                    win_h = $("#deter_topology").height();

                svg.attr("width", win_w - margin.left - margin.right)
                   .attr("height", win_h - margin.top - margin.bottom);
            }

            function zoomed() {
                newest_zoom = d3.event.transform;
                node_selection.selectAll(".node").attr("transform", newest_zoom); 
                link_selection.selectAll("path").attr("transform", newest_zoom);
            }

            function dragstarted(d) {
                if (!d3.event.active) simulation.alphaTarget(0.1).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(d) {
                d.fx = d3.event.x;
                d.fy = d3.event.y;
            }

            function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            var exp_name_promise = new Promise(
                function(resolve, reject) {
                    d3.json(window.location.origin + '/api/exp_info',
                        function(error, json) {
                            if(error) reject(error); 
                            else if (json.status !== 0) {
                                // This can happen if the correct agent is not running.
                                reject('server did not give us the exp info.');
                            }
                            else {
                                console.log("got exp_info: ", json); 
                                resolve(json);
                            }
                        }
                    );
                }
            ).then(
                function(expinfo) {
                    $("#deter_topology_chart_title").html("Experiment: <b>" + expinfo.project + " / "
                        + expinfo.experiment + "</b>"); 
                }, 
                function(message, error) {
                    $("#deter_topology_chart_title").html("Topology"); 
                    console.log(message, error);
                }
            );

            var load_topology_promise = new Promise(
                function(resolve, reject) {
                    // GTL FIX d3.json(window.location.origin + '/api/topology/' + "{{ agent.table }}",
                    d3.json(window.location.origin + "/api/topology/" + "routes_agent", 
                        function(error, json) {
                            if (error) reject(error);
                            else if (json.status !== 0) reject("server did not give the topology");
                            else resolve(json)
                        }
                    );
                }
            ); 
                
            load_topology_promise.then(function load_topology(json) {
                // build the nodes and links teh way the graph widget wants them
                for(var i = 0; i < json['nodes'].length; i++) {
                    n = json['nodes'][i];
                    nodes.push({name: n, id: i});
                }
                for(var i = 0; i <  json['edges'].length; i++) {
                    s = json['edges'][i][0]
                    t = json['edges'][i][1]
                    si = json['nodes'].indexOf(s);
                    ti = json['nodes'].indexOf(t);
                    name = s + '-' + t
                    console.log('adding link', s, t, name);
                    links.push({source: si, target: ti, name: name, linknum: null});
                }

                update_topo();
                d3.select("#disp_route_button").classed("disabled", false); 
            });

            function remove_all_paths() {
                console.log("removing all paths");
                for(var i=0; i<links.length; i++) {
                    if (links[i].hasOwnProperty('route')) {
                        console.log("removing link: ", links[i]);
                        links.splice(i, 1);
                        i--;   // we just removed an element.
                    }
                }
                for(var i=0; i<selected_path_nodes.length; i++) {
                    delete selected_path_nodes[i];  // set slot to undefined.
                }
                route_dropdown_menu.splice(0, route_dropdown_menu.length);  // kill all menu items.
                route_dropdown_menu.push(clear_all_routes_menu_entry);
                update_topo();
            }

            function handle_clear_route(d) {
                console.log("removing path:" , d); 
                if (d.id == "clear_all_routes") {
                    remove_all_paths();
                    return;
                }
                for(var i=0; i<links.length; i++) {
                    if (links[i].hasOwnProperty('route') && links[i].route === d.src + "-" + d.dst) {
                        console.log("removing link: ", links[i]);
                        links.splice(i, 1);
                        i--;   // we just removed an element.
                    }
                }
                delete selected_path_nodes[d.slot];  // set slot to undefined. 
                var i = route_dropdown_menu.findIndex(function(x) { return x.slot == d.slot; });
                if (i != -1) { 
                    route_dropdown_menu.splice(i, 1);   // remove it here, will remove it from the menu.
                } else {
                    console.log("unable to find in drop down menu: ", d); 
                }

                update_topo();
            }

            function show_path(path_slot) {
                var path_show_promise = new Promise(
                    function(resolve, reject) {
                        url = window.location.origin + '/api/routing/path?';
                        url += "src=" + selected_path_nodes[path_slot].src.name;
                        url += "&dst=" + selected_path_nodes[path_slot].dst.name;
                        d3.json(url, 
                            function(error, json) {
                                if (error) reject(error);
                                else if (json.status !== 0) {
                                    reject("Server could not find that path");
                                }
                                else {
                                    console.log("Got path: ", json.path);
                                    resolve(json);
                                }
                            }
                        );
                    }
                );
            
                path_show_promise.then(
                    function(json) {
                        path_nodes = json["path"]
                        route_name = path_nodes[0] + "-" + path_nodes[path_nodes.length-1]
                        for(var i = 0; i < path_nodes.length-1; i++) {
                            s = path_nodes[i]
                            t = path_nodes[i+1]
                            si = simulation.nodes().findIndex(function(n) { return n.name == s; });
                            ti = simulation.nodes().findIndex(function(n) { return n.name == t; });
                            name = s + "-" + t
                            console.log('adding route path link', si, ti, name, route_name);
                            links.push({source: si, target: ti, name: name,
                                linknum: path_slot, route: route_name});
                        }
                        var src = path_nodes[0],
                            dst = path_nodes[path_nodes.length-1];
                        route_dropdown_menu.push({
                            id: src + dst + path_slot,
                            text: src + " --> " + dst,
                            src: src, dst: dst, slot: path_slot,
                            color: route_color(path_slot)
                        });
                        d3.select("#disp_route_button").classed("disabled", false); 
                        d3.select(".choose-nodes-message").remove()
                        choosing_path = false;
                        path_slot = -1;
                        update_topo();
                    },
                    function(message, error) {
                        console.log(message, error);
                    }
                );
            }

            function update_topo() {
                console.log("updating topology");

                // var link = link_selection.selectAll("path").data(links).enter()
                var link = link_selection.selectAll("path").data(links)
                var node = node_selection.selectAll(".node").data(nodes).enter().append("g").attr("class", "node")

                // update link attrs for existing links.
                link.attrs(function(d) { return link_attrs(d); }); 

                // enter (new links) - create link DOM.
                link.enter().append("path")
                    .attr("class", "link")
                    .attr("fill", "none")
                    .attr("transform", newest_zoom);   // make sure to translate new links/paths.

                node.append("circle")
                    .attr("r", "6")
                    .attr("fill", function(d) { return get_node_fill(d); })
                    .attr("stroke", function(d) { return get_node_stroke(d); })
                    .on("click", function(d) { click_node(d); })
                    .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended))

                node.append("text")
                    .attr("x", 12)
                    .attr("dy", ".35em")
                    .attr("font", "10px sans-serif")
                    .attr("pointer-events", "none")
                    .attr("fill", "black")
                    .text(function(d) { return d.name })

                node.on("mouseover", function(d) { set_highlight(d); })
                    .on("mouseout", function(d) { exit_highlight(d); })

                // remove links no longer in the DOM.
                link.exit().remove(); 
                node.exit().remove();

                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.restart();

                // "slot" is the unique ID for each menu entry as it maps to the index of the entry in the paths array.
                var menu = route_dropdown_menu_selection
                    .selectAll("li")
                    .data(route_dropdown_menu, function(d) { return d.slot; })
                // update existing menu entries with text/color. 
                menu.selectAll("a")
                    .style("background-color", function(d) { return d.color; })
                    .text(function(d) { return d.text; })

                // create and set new entries.
                menu.enter()
                    .append("li")
                    .append("a")
                        .attr("href", "#")
                        .attr("id", function(d) { return d.id; })
                        .style("background-color", function(d) { return d.color; })
                        .text(function(d) { return d.text; })
                        .on("click", handle_clear_route)

                // remove missing entries.
                menu.exit().remove()

                // If there is only one menu entry (clear all), then disable the menu.
                d3.select("#clear_route_button")
                    .classed("disabled", function() { return route_dropdown_menu.length == 1; })

            };  // end of update_topo()

            function get_node_stroke(d) {
                return "blue";
            }

            function get_node_fill(d) {
                if (d.hasOwnProperty("route_selected")) {
                    return route_color(d.route_selected); 
                }
                return "#8be47c";
            }

            function click_node(d) {
                if (!choosing_path) {
                    return;
                }
                if (path_slot < 0) { // this is the first node clicked.
                    path_slot = selected_path_nodes.findIndex(function(x) { return x === undefined; });
                    if (path_slot >= 0) {
                        selected_path_nodes[path_slot] = {src: d, dst: null};
                    } else {  // create a new slot. 
                        selected_path_nodes.push({src: d, dst: null}); 
                        path_slot = selected_path_nodes.length - 1;
                    }
                    d.route_selected = path_slot;
                    console.log("first path node: ", d.name); 
                    var message = d3.select(".choose-nodes-message")
                                    .text("Node " + d.name + " chosen. Choose node two."); 
                } else {   // this is the second node chosen.
                    console.log("route dst: ", d.name);
                    selected_path_nodes[path_slot].dst = d;
                    show_path(path_slot); 
                    delete selected_path_nodes[path_slot].src.route_selected; // unselect the first node.
                    path_slot = -1; 
                }
            }

            function set_highlight(d) {
                svg.style("cursor", "pointer");
            }

            function exit_highlight(d) {
                svg.style("cursor", "move");
            }

            function link_stroke(d) {

            }

            function link_attrs(d) {
                var atts = {};
                if (d.linknum === null) {
                    // Straight black slightly less opaque line.
                    atts["d"] = "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
                    atts["stroke"] = "black";
                    atts["stroke-opacity"] = 0.25;
                    atts["stroke-width"] = 1.0; 
                } else {
                    var dx = d.target.x - d.source.x,
                        dy = d.target.x - d.source.y,
                        dr = Math.sqrt(((d.linknum+1) * dx * dx) + ((d.linknum+1) * dy * dy));

                    atts["d"] = "M" + d.source.x + "," + d.source.y + 
                                "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;


                    atts["stroke"] = route_color(d.linknum);
                    atts["stroke-opacity"] = 1.0;
                    atts["stroke-width"] = 1.5; 
                    atts["marker-end"] = "url(#end)";
                }

                return atts
            }

            function ticked() {
                var link = link_selection.selectAll("path");
                var node = node_selection.selectAll(".node");
                var circle = node.selectAll("circle");

                link.attrs(function(d) { return link_attrs(d); }); 

                // node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
                node.selectAll("circle").attr("cx", function(d) { return d.x; })
                node.selectAll("circle").attr("cy", function(d) { return d.y; })
                node.selectAll("text").attr("x", function(d) { return d.x + 8; })
                node.selectAll("text").attr("y", function(d) { return d.y; })

                circle.attr("fill", function(d) { return get_node_fill(d); })
                      .attr("stroke", function(d) { return get_node_stroke(d); })
            }

            d3.select("#disp_route_button").on("click", function() {
                d3.select(this).classed("disabled", true);
                choosing_path = true;   // we are now choosing a path.
                var mess_area = d3.select("#message_area")
                    .append("div")
                    .attr("class", "alert alert-success choose-nodes-message")

                mess_area.append("text").text("Choose first node")
            });

        </script>
    </div>
</div>
<!-- selected node info -->
<div class="container-fluid">
    <div class="row" id="node_panels">
        <link type="text/css" rel="stylesheet" href="{{ url_for('static', filename='css/horizon_chart.css') }}"></link>
    </div>
</div>
{% endblock %}
